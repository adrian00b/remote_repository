USTAWIENIA:
git config
	--list - pokazuje liste roznych ustawien gita
	--global user.name "asd" - globalnie ustawia uzytkownika, bez uzycia opcji global nazwa bedzie przypisana
	do danego projektu
	-- config user.name - pokazuje user.name
	
	oczywiscie user.name jest dla przykladu, mozna znalezc wiele innych wartosci, np. user.email etc 

POMOC:
git help 'komenda' - pokazuje pomoc

TWORZENIE REPOZYTORIUM:
git init - stworzenie repozytorium
git clone 'adres' - sklonowanie calego repo z jakiegos zrodla (github) 
git clone 'adres' nazwa - mozna dopisac nazwe foledru w jakim ma to byc zapisane

DODAWANIE ZMIAN:

git status - aktualny status REPOZYTORIUM
		-s - skrocona forma pokazujaca skroty:
			?? niesledzone pliki
			A nowe pliki dodane do poczekalni
			M zmodyfikowane pliki
			pierwsza kolumna oznacza pliki dodane do poczekalni, druga nie dodane do poczekalni

git add - dodanie pliku do przechowalni : 
	git add . - dodanie wszystkich plikow
	git add nazwapliku - dodanie konkretnego pliku 
	
git commit - zapisanie zmian w repozytorium  :
	git commit -m "Komentarz:  - zapisanie zmian w repozytorium wraz z komentarzem
	-a - commituje kazdy zmieniony plik bez koniecznosci dodawania go do poczekalni
		za pomoca git add  

git diff - pokazuje roznice dla plikow ktore nie sa jeszcze w poczekalni
git difftool - pokazuje roznice w zewnetrznym narzedziu

git mv 'dir1' 'dir2' - zmiana nazwy pliku albo directory z 1 na 2
	uwaga! jaka jest roznica miedzy ta operacja a standardowym linuxowym mv? tutaj git wie ze jest to rename i wystaczy dac commita
	w przypadku konsolowego mv, trzeba zrobic add->commit, ale git widzi to jako usuniecie pliku o starej nazwie i dodanie nowego (a nie sama zmiana nazwy)

COFANIE ZMIAN:

git commit --amend  - pozwala na uaktualnienie ostatniego commita, np. zmiane commit message 
	jezeli zapomnielismy o pewnej zmiane ktora powinna byc w poprzednim commicie, to dokonujemy zmiany, uzywamy git add, i po uzyciu git commit--amend na miejscu tamtego commita powstaje nowy ktory ma ta zmiane - mamy rowniez mozliwosc ponownego stworzenia message

git clean - sluzy do usuniecia plikow ktore nigdy nie zostaly dodane do repozozytorium (niesledzone pliki i katalogi), 
	UWAGA! zmiany nie da sie odwrocic
	git clean -n   - zwraca liste plikow ktore moga zostac usuniete
	git clean -nd  - tutaj pokaze sie kompletna lista - wraz z katalogami 
	git clean -idf - (i) interaktywnie, (d) katalogi, jezeli chcemy usunac tylko wybrane
	
git reset - usuniecie z przechowywalni (cofniecie plikow ze stage), odwrotnosc polecenia git add   
	 
git checkout - usuniecie zmian z plikow bedacych w przechowali
	* - wszystkie pliki
	-- nazwa pliku - konkretny plik

git rm nazwapliku - usuniecie pliku z repozytorium (i katalogu roboczego rowniez),
 roznica miedzy git rm a git clean polega na tym ze uzywajac git rm zmiany da sie odwrocic!! odwrocic checkoutem
 
git log - pokazuje historie zmian wraz z logami, aby wyjsc z historii zmian klawisz Q
	--oneline - pokazuje historie zmian w skroconej formie zapisu 
	--graph - pokazuje zmiany razem z roznymi branchami (pokazuje rozgalezienia)
	-4 - pokazuje liczbe commitow, w tym przypadku 4
	--since/after='data' lub wyrazenie typu 2.weeks, 1.moth, days etc
	--until/before='data'
	--pretty=short/full/fuller - format pokazywanych commitów
	--pretty=format:'...' sami możemy określić format wyswietlania commitow 
	-p - pokazuje zmiany dokonany w poszczególnych commitach
	--stat - pokazuje proste statystyki dokonanych w commicie zmian
	--author "" - pokazuje commity stworzonego przez danego autora
	--grep "" - pokazuje commity zawierajace w komentarzu podana fraze
	UWAGA! w przypadku stosowania autora i grep jednoczesnie nalezy dodac opcje --all-match
	--"sciezka" - pokazuje historie danego pliku (podawane na koncu, po parametrach)
	--patch - pokazuje zmiany dokonane w pliku
	-summary - tez pewne podsumowanie zmian

	
git shortlog - historia z podzialem na uzytkownikow (uproszczone w oneline od razu)
	
git checkout 'log' - przywraca stan z wybranego commita, jednakze otwiera to w stanie 'HEAD detached', czyli mozna dowolnie
	wprowadzac zmiany w plikach bez zapisywania tego gdziekolwiek - pozniej mozemy zapisac zmiany w osobnym branchu:
	
	git checkout 'log' 'file' - przywraca stan wybranego pliku 'file' z danego commita
	git checkout -b - zapisanie w nowym branchu
	git checkout master - powrot do glownego brancha (najabrdziej aktualnej wersji spred git checkout 'log')
	git checkout 'branch_name' - przelaczenie sie na wybrany branch
	
git revert 'log' - odwrocenie zmian z wybranego commitu i zapisanie ich jako nowy commit, NIE USUWA HISTORII!!

git reset 'log' - przywraca wybrany commit - UWAGA! modyfikuje historie 
	
	git reset 'log' --hard - przywraca stan z danego commita usuwajac dokonane po nim zmiany i commity
		oznacza to ze usuwa wszystkie commity z historii i nie bedzie sie dalo do nich wrocic
		
	git reset 'log' --mixed - usuwa historie commitow ale w katalogu roboczym pozostawia zmiany,
		ktore mozna dodac add i pozniej scommitowac, albo odrzucic checkout .
	
	git reset 'log' --soft - analogicznie jak mixed tylko zmiany sa juz w przechowalni add - wystarczy scommitowac albo odrzucic


-- help  - dopisane do jakiegokolwiek polecenia otwiera nam dokumentacje dotyczaca jego parametrow etc

git branch 'name' - utworzenie nowego brancha
	git branch  - pokazuje wszystkie istniejace branche
	git branch -D 'name' - usuniecie nieptorzebnego branchu

git merge 'name' - laczenie zmian z dwoch branchy, musimy byc na branchu ktory jest bardziej pdostawowy 
	np. jezeli na branch master chcemy dodac zmiany z brancha dev to musimy przelaczyc sie na branch master
	poleceniem git checkout master i tam dokonac zmergowania	


git stash - UWAGA! jezeli dzialamy na roznych branchach, mozemy przed commitem chciec sie przelaczyc na inny branch
	sytuacja taka moze spowodowac, ze zmiany zostana nadpisane przy przelaczaniu i znikna bo nie dalismy commita
	w tej sytuacji mozemy uzyc polecenia git stash, ktory dodaje zmiany na stos, do poczekalni, na pozniej 
	
	git stash pop - po wykonaniu git stash mozemy przelaczyc sie na inny branch i tam zaladowac zmiany dokonane
		na wczesniejszym branchy ale nie scommitowane - w ten sposob wczytamy tamte zmiany, mimo iz w branchu 
		np. dev tego nie ma 
		
	git stash push -m " ..." - zapisanie zmian na stos wraz z komentarzem 
	
	git stash list - lsita zmian na stosie
	
	git stash clear - czysci caly stos bez wczytywania zmian
	
	git drop "id stash' - usuniecie wybranego wpisu ze stashu
	
	git stash branch 'name' - zmiany ze stasha moga zostac przeniesione od razu na brancha
	
	
git rebase - ulatiwa zapis historii, branch w logach staje sie jakby kontynuacja branchu master, a nie oddzielna
	galezia
	
	
REMOTE REPOSITORY

git remote add origin 'adres zrodla' - dodanie zdalnego repozytorium o nazwie origin 

git remote - pokazuje liste repozytoriow (skroocne nazwy)
	-v - pokazuje adresy 
	git remote show 'nazwa' - pokazuje informacje o zdalnym repo
	git remote rename 'old_name' 'new_name' - zmiana nazwy zdalnego repo
	git remote rm 'name' - usuniecie zdalnego repo 

git push -u origin master - pierwsze przeslanie zmian z lokalnego repo do zdalnego, kolejne moga byc przesylane
	samym poeceniem git push 

git pull - pobiera pliki ze zdalnego repozytorium

git fetch - pobiera same zmiany, nie pliki, nie dokonuje jeszcze zmian, po tym poleceniu mozemy zrobic kolejne polecenie:

git merge origin/master - to nam uaktualni lokalne repo 


TAGOWANIE
git tag - sprwadzenie lsity tagów
	-l 'text' , mozna uzywac wildcard np. 'v1.*' - wyszukiwanie konkretnych tagów

git tag -a 'text' -m 'comment' - dodawanie tagu w formie opisanej
